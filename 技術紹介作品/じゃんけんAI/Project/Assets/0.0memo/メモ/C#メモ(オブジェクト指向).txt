オブジェクト指向三大要素
・継承(インヘリタンス)
・カプセル化
・ポリモーフィズム

----------------------------------------------------------------------

現実世界をプログラム上に再現する考え方
オブジェクト,”モノ”に着目することが重要

プログラムもオブジェクト単位で記述
{
	オブジェクトが持つ
	・データ(プロパティ)
	・ふるまい(メソッド)
	これらをまとめてクラスにまとめる
	Enemy
	{
		int Hp;
		int Atk;

		void attack(){}
	}
}

----------------------------------------------------------------------

インスタンス化
クラスは悪魔で設計図なので生成する

----------------------------------------------------------------------

--- 継承(インヘリタンス) ---

・あるクラスの機能(プロパティ、メソッド)を引き継いだクラスを作ること
・コードの重複を減らし再利用性を高める

------
継承はゲーム開発で問題がある
ほしい共通機能がたくさんあるがそれがいらないものが発生したりするので
継承先で切り替えは大変だし無駄が多くなるのでUnityで採用されているのは
Unity コンポーネント指向(オブジェクト指向の一部)
Unity におけるGameObjectが持っているのはTransformだけ
あとは必要に応じてコンポーネントとして足す
------
子クラスにとって必要ない機能が親クラスに含まれているな
むしろ親クラスに邪魔されてうまく子クラスを作れない
と感じたらだいたい継承がうまくいってない
------

----------------------------------------------------------------------

--- カプセル化(隠ぺい) ---

作ったクラスをカバー
うっかり触ったら予期せぬ動作をするかもしれないプロパティを隠す
クラス内でしか使う必要のないメソッドを隠す
そうすることでトラブルを防げるという考え方

C#カプセル化を実現する方法
アクセス修飾子を使うpublic／protected／private
まずはprivateから
継承先でも必要→protected
他のクラスからでもアクセスする必要がある→public
-----
// 取得はpublic、値の設定はprivate
public int Atk {get; private set;}

// このように別々の値を設定することも可

// privateのままインスペクター上に表示してゲッターを作る
[SerializeField] private int atk;
public int Atk => atk;
// ↓ これの省略形
//public int Atk { get => atk; }


----------------------------------------------------------------------

--- ポリモーフィズム(多態性/多様性) ---
オーバーライド
オーバーロード

abstractクラス(抽象クラス)必ず継承して使うクラスのこと

// オーバーライド(再定義)
public abstract class Animal
{
    // 鳴き声を取得
    // abstractメソッド(抽象メソッド)：実装は抽象先に任せる
    // 例えば動物の鳴き声を教えてください。→それは動物によります。
    // まさにこれを表現できる
    public abstract string GetCall();

    //↓abstractクラスじゃない場合はvirtul
    //public virtual string GetCall()
    //{
    //	return "...";
    //}

    // abstract は abstract クラスでしか使えない
    // virtual は普通のクラスで使える
}

//犬
public class Dog : Animal
{
    public override string GetCall()
    {
        return "ワンッ！";
    }
}

//猫
public class Cat : Animal
{
    // このときオーバーライドせずに
    // 実装しないとエラーが出る
    public override string GetCall()
    {
        return "にゃー";
    }
}
// 使い方
public class AnimalTest : MonoBehaviour
{
    private void Start()
	{
        Dog dog = new Dog();
        Debug.Log(dog.GetCall());
        Cat cat = new Cat();
        Debug.Log(cat.GetCall());

        // ここまでなら各クラスにGetCall()を実装すればいい話なのでメリットはないが..

        // Animalクラスを経由することで、
        // 犬なのか猫なのかプログラム上ではわからなくても鳴き声を確認できる
        Animal animal;
        if(Random.Range(0,2) == 0)
		{
            animal = dog;
        }
        else
		{
            animal = cat;
		}
        Debug.Log(animal.GetCall());    // ワンッ！ or にゃー
    }
}

// オーバーロード(多重定義)
// 引数の数 or 引数の型 どちらか違えば
// 同じクラス内かつ同じ名前のメソッドを何個でも定義できる
    public int Max(int a, int b)
    {
        if(a > b) return a;
        return b;
    }
    public float Max(float a, float b)
    {
        if (a > b) return a;
        return b;
    }